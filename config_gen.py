#!/usr/bin/env python2
'''
generate cpp vim-syntastic config
'''
import sys
import os
import os.path
import re
import argparse
import datetime
import multiprocessing
import shlex
import tempfile
import time
import subprocess

plugin_dir = os.path.dirname(os.path.realpath(__file__))

def run(cmd, *args, **kwargs):
    '''helper function to display exact commands used'''
    print '$ ' + ' '.join(cmd)
    subprocess.call(cmd, *args, **kwargs)

def env_config(*args, **kwargs):
    '''subprocess env config'''
    fake_path = args[0]
    build_log_path = args[1]
    compiler = kwargs['compiler']
    preserve_environment = kwargs['preserve_environment']
    env = {}
    if preserve_environment:
        env = os.environ
    else:
        # Preserve HOME, since Cmake needs it to find some packages and it's
        # normally there anyway
        env = dict(map(lambda x: (x, os.environ[x]), ['HOME']))
    env['PATH'] = '{}:{}'.format(fake_path, os.environ['PATH'])
    env['COMPILER'] = compiler
    env['GEN_LOG_PATH'] = build_log_path.name
    return env

def process_config(*args, **kwargs):
    '''subprocess config'''
    dev_null = open(os.devnull, 'w')
    process_opts = {} if kwargs['verbose'] else {
        'stdin': dev_null,
        'stdout': dev_null,
        'stderr': dev_null
        }
    process_opts['cwd'] = kwargs['project_dir']
    return process_opts

def fake_build(build_log_path, *args, **kwargs):
    '''get build log'''
    make = kwargs['make']
    make_flags = kwargs['make_flags']
    build_system = kwargs['build_system']
    fake_path = os.path.join(plugin_dir, 'fake-toolchain', 'Unix')
    assert os.path.exists(fake_path), 'Could not find toolchain at {}'.format(fake_path)
    make_cmd = [make] + make_flags
    env = env_config(fake_path, build_log_path, **kwargs)
    process_opts = process_config(**kwargs)
    build_start_time = time.time()
    if build_system == 'make':
        print 'Preparing build directory...'
        run(make_cmd + ['clean'], env=env, **process_opts)
        print '\nRunning make...'
        run(make_cmd, env=env, **process_opts)
    build_end_time = time.time()
    print('Build completed in {} sec'.format(round(build_end_time -
                                                   build_start_time, 2)))

def parse_flags(build_log_path):
    '''get flag we want'''
    # flags we want
    # -include (-i,-I)
    flags_whitelist = ["-[iI].*"]
    flags_whitelist = re.compile("|".join(map("^{}$".format, flags_whitelist)))
    # Used to only bundle filenames with applicable arguments
    filename_flags = ["-I", "-isystem", "-iquote", "-include",
                      "-imacros", "-isysroot"]
    flags = set()
    line_count = 0
    for line in build_log_path:
        line_count += 1
        words = split_flags(line)
        for (i, word) in enumerate(words):
            if word[0] != '-' or not flags_whitelist.match(word):
                continue
            # include arguments for this option, if there are any, as a tuple
            if(i != len(words) - 1
               and word in filename_flags
               and words[i + 1][0] != '-'):
                flags.add((word, words[i + 1]))
            else:
                flags.add(word)
    return (line_count, flags)

def split_flags(line):
    '''
    splits a string into flags,Flags are space-seperated, except for spaces
    enclosed in quotes.Returns a list of flags
    '''
    words = line.strip().split()
    res = []
    for word in words:
        if len(res) > 0 and unbalanced_quotes(res[-1]):
            res[-1] += " " + word
        else:
            res.append(word)
    return res

def unbalanced_quotes(string):
    '''returns True if the no. of single or double quotesin s is odd.'''
    single = 0
    double = 0
    for char in string:
        if char == "'":
            single += 1
        elif char == '"':
            double += 1
    return single % 2 == 1 or double % 2 == 1

def generate_conf(flags, config_file):
    '''generate vim-syntastic config file'''
    with open(config_file, "w") as output:
        output.write('# Generated by vim-syntastic-generator at'
                     ' {}\n\n'.format(str(datetime.datetime.today())))
        for flag in flags:
            if isinstance(flag, basestring):
                output.write('{}\n'.format(flag))
            else:
                output.write('{}\n{}\n'.format(*flag))

def main():
    '''entry function'''
    # default flags for make
    default_make_flags = ['-i', '-j' + str(multiprocessing.cpu_count())]
    # parse command-line args
    parser = argparse.ArgumentParser(description='Automatically generates'
                                     ' config files for vim-syntastic')
    parser.add_argument('-v', '--verbose', action='store_true', help='Show'
                        ' output from build process')
    parser.add_argument('-f', '--force', action='store_true', help='Overwrite'
                        ' the file if it exists.')
    parser.add_argument('-c', '--compiler', default='gcc', help='Use the specified compiler')
    parser.add_argument('-o', '--output', help='Save the config file as'
                        ' OUTPUT. Default: .vim_syntastic_cpp_config')
    parser.add_argument('-m', '--make', default='make', help='Use the'
                        ' specified executable for make.')
    parser.add_argument(
        '-M', '--make-flags', help='Flags to pass to make'
        ' when fake-building. Default: -M="{}"'.format(' '.join(default_make_flags)))
    parser.add_argument('-b', '--build-system', choices=['make'], default='make',
                        help='Force use of the specified build system rather than trying to')
    parser.add_argument('-e', '--preserve-environment', action='store_true',
                        help='Pass environment variables to build processes.')
    parser.add_argument('PROJECT_DIR', help='The root directory of the project.')
    args = vars(parser.parse_args())
    conf = {}
    project_dir = os.path.abspath(args['PROJECT_DIR'])
    # verify that project_dir exists
    if not os.path.exists(project_dir):
        print 'ERROR: "{}" does not exist'.format(project_dir)
        return 1
    conf['project_dir'] = project_dir
    # verify compilers
    try:
        compiler = args['compiler']
        compiler = subprocess.check_output(['which', compiler]).strip()
    except subprocess.CalledProcessError:
        print('ERROR: Could not find clang at "{}". Please make sure it is'
              ' installed and is either in your path, or specified with'
              ' --compiler.'.format(compiler))
        return 1
    conf['compiler'] = compiler
    # prompt user to overwrite existing file (if necessary)
    if args['output'] is None:
        output = os.path.join(project_dir, '.vim_syntastic_cpp_config')
    else:
        output = args['output']
    if os.path.exists(output) and not args['force']:
        print('"{}" already exists. Overwrite? [y/N] '.format(output)),
        response = sys.stdin.readline().strip().lower()
        if response != 'y' and response != 'yes':
            return 1
    conf['output'] = output
    if args['make_flags'] is None:
        make_flags = default_make_flags
    else:
        make_flags = shlex.split(args['make_flags'])
    conf['make_flags'] = make_flags
    conf['make'] = args['make']
    conf['verbose'] = args['verbose']
    conf['build_system'] = args['build_system']
    conf['preserve_environment'] = args['preserve_environment']
    # temporary files to hold build logs
    with tempfile.NamedTemporaryFile(mode='rw') as build_log:
        fake_build(build_log, **conf)
        (count, flags) = parse_flags(build_log)
        print 'Collected {} relevant entries for compilation.'.format(count)
        if count == 0:
            print('ERROR: No commands were logged to the build logs '
                  ' {}'.format(build_log.name))
            print 'Your build system may not be compatible.'
            if not conf['verbose']:
                print('Try running with the --verbose flag to see build'
                      ' system output - the most common cause of this is a'
                      ' hardcoded compiler path.')
            build_log.delete = False
            return 3
        generate_conf(flags, output)
        print 'Created config file with {} flags'.format(len(flags))

if __name__ == '__main__':
    sys.exit(main())
